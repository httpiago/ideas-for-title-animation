{"version":3,"sources":["webpack:///src/watcher.js","webpack:///webpack/universalModuleDefinition","webpack:///scrollMonitor.js","webpack:///webpack/bootstrap b221bc136e7e9b3db562","webpack:///index.js","webpack:///src/constants.js","webpack:///src/container.js","ts/focus-effect.ts"],"names":["ElementWatcher","root","factory","module","exports","amd","define","this","modules","moduleId","installedModules","id","loaded","call","__webpack_require__","m","c","p","_require","isInBrowser","scrollMonitor","document","body","setStateFromDOM","listenToDOM","window","VISIBILITYCHANGE","ENTERVIEWPORT","FULLYENTERVIEWPORT","EXITVIEWPORT","PARTIALLYEXITVIEWPORT","LOCATIONCHANGE","STATECHANGE","eventTypes","isOnServer","defaultOffsets","top","bottom","element","innerHeight","documentElement","clientHeight","Math","max","scrollHeight","offsetHeight","pageYOffset","scrollTop","Watcher","browserSupportsPassive","Object","defineProperty","get","addEventListener","opts","e","capture","passive","ScrollMonitorContainer","item","parentWatcher","_classCallCheck","instance","Constructor","TypeError","self","calculateViewportI","updateAndTriggerWatchersI","watchers","viewportTop","viewportBottom","documentHeight","getContentHeight","viewportHeight","getViewportHeight","DOMListener","prototype","apply","arguments","containerWatcher","create","update","previousDocumentHeight","length","recalculateLocation","calculateViewport","triggerCallbacks","updateAndTriggerWatchers","recalculateLocations","useCapture","attachEvent","destroy","removeEventListener","detachEvent","event","contentHeight","setState","newViewportTop","newViewportHeight","newContentHeight","latestEvent","needsRecalcuate","i","createCustomContainer","createContainer","querySelector","container","offsets","watcher","push","beget","watchItem","listeners","listenerToTriggerListI","listener","callback","isOne","splice","wasFullyInViewport","wasAboveViewport","wasBelowViewport","callbacks","j","locked","isInViewport","wasInViewport","triggerCallbackArray","isFullyInViewport","isAboveViewport","isBelowViewport","previousBottom","nodeName","style","display","cachedDisplay","containerOffset","boundingRect","getBoundingClientRect","height","undefined","previousTop","on","Error","join","off","one","recalculateSize","indexOf","index","lock","unlock","type","eventHandlerFactory"],"mappings":"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","file":"focus-effect.83f76a45.js","sourceRoot":"..\\src","sourcesContent":["var {\n\tVISIBILITYCHANGE,\n\tENTERVIEWPORT,\n\tFULLYENTERVIEWPORT,\n\tEXITVIEWPORT,\n\tPARTIALLYEXITVIEWPORT,\n\tLOCATIONCHANGE,\n\tSTATECHANGE,\n\teventTypes,\n\tdefaultOffsets\n} = require('./constants');\n\nfunction ElementWatcher (containerWatcher, watchItem, offsets) {\n\tvar self = this;\n\n\tthis.watchItem = watchItem;\n\tthis.container = containerWatcher;\n\n\tif (!offsets) {\n\t\tthis.offsets = defaultOffsets;\n\t} else if (offsets === +offsets) {\n\t\tthis.offsets = {top: offsets, bottom: offsets};\n\t} else {\n\t\tthis.offsets = {\n\t\t\ttop: offsets.top || defaultOffsets.top,\n\t\t\tbottom: offsets.bottom || defaultOffsets.bottom\n\t\t};\n\t}\n\n\tthis.callbacks = {}; // {callback: function, isOne: true }\n\n\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\tself.callbacks[eventTypes[i]] = [];\n\t}\n\n\tthis.locked = false;\n\n\tvar wasInViewport;\n\tvar wasFullyInViewport;\n\tvar wasAboveViewport;\n\tvar wasBelowViewport;\n\n\tvar listenerToTriggerListI;\n\tvar listener;\n\tfunction triggerCallbackArray (listeners, event) {\n\t\tif (listeners.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tlistenerToTriggerListI = listeners.length;\n\t\twhile (listenerToTriggerListI--) {\n\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\tlistener.callback.call(self, event, self);\n\t\t\tif (listener.isOne) {\n\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t}\n\t\t}\n\t}\n\tthis.triggerCallbacks = function triggerCallbacks (event) {\n\n\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t}\n\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t}\n\n\n\t\tif (this.isAboveViewport !== wasAboveViewport &&\n\t\t\tthis.isBelowViewport !== wasBelowViewport) {\n\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\n\t\t\t// if you skip completely past this element\n\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t\t}\n\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t}\n\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t}\n\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\t\t}\n\t\tswitch( true ) {\n\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\ttriggerCallbackArray( this.callbacks[STATECHANGE], event );\n\t\t}\n\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\n\t};\n\n\tthis.recalculateLocation = function () {\n\t\tif (this.locked) {\n\t\t\treturn;\n\t\t}\n\t\tvar previousTop = this.top;\n\t\tvar previousBottom = this.bottom;\n\t\tif (this.watchItem.nodeName) { // a dom element\n\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t}\n\n\t\t\tvar containerOffset = 0;\n\t\t\tvar container = this.container;\n\t\t\twhile (container.containerWatcher) {\n\t\t\t\tcontainerOffset += container.containerWatcher.top - container.containerWatcher.container.viewportTop;\n\t\t\t\tcontainer = container.containerWatcher.container;\n\t\t\t}\n\n\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t}\n\n\t\t} else if (this.watchItem === +this.watchItem) { // number\n\t\t\tif (this.watchItem > 0) {\n\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t} else {\n\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t}\n\n\t\t} else { // an object with a top and bottom property\n\t\t\tthis.top = this.watchItem.top;\n\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t}\n\n\t\tthis.top -= this.offsets.top;\n\t\tthis.bottom += this.offsets.bottom;\n\t\tthis.height = this.bottom - this.top;\n\n\t\tif ( (previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom) ) {\n\t\t\ttriggerCallbackArray( this.callbacks[LOCATIONCHANGE], null );\n\t\t}\n\t};\n\n\tthis.recalculateLocation();\n\tthis.update();\n\n\twasInViewport = this.isInViewport;\n\twasFullyInViewport = this.isFullyInViewport;\n\twasAboveViewport = this.isAboveViewport;\n\twasBelowViewport = this.isBelowViewport;\n}\n\nElementWatcher.prototype = {\n\ton: function (event, callback, isOne) {\n\n\t\t// trigger the event if it applies to the element right now.\n\t\tswitch( true ) {\n\t\t\tcase event === VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\tcase event === ENTERVIEWPORT && this.isInViewport:\n\t\t\tcase event === FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\tcase event === EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\tcase event === PARTIALLYEXITVIEWPORT && this.isInViewport && this.isAboveViewport:\n\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\tif (isOne) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks[event]) {\n\t\t\tthis.callbacks[event].push({callback: callback, isOne: isOne||false});\n\t\t} else {\n\t\t\tthrow new Error('Tried to add a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\toff: function( event, callback ) {\n\t\tif (this.callbacks[event]) {\n\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\tone: function( event, callback ) {\n\t\tthis.on( event, callback, true);\n\t},\n\trecalculateSize: function() {\n\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\tthis.bottom = this.top + this.height;\n\t},\n\tupdate: function() {\n\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\n\t\tthis.isInViewport = (this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop);\n\t\tthis.isFullyInViewport = (this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom) || (this.isAboveViewport && this.isBelowViewport);\n\n\t},\n\tdestroy: function() {\n\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\tself  = this;\n\t\tthis.container.watchers.splice(index, 1);\n\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[eventTypes[i]].length = 0;\n\t\t}\n\t},\n\t// prevent recalculating the element location\n\tlock: function() {\n\t\tthis.locked = true;\n\t},\n\tunlock: function() {\n\t\tthis.locked = false;\n\t}\n};\n\nvar eventHandlerFactory = function (type) {\n\treturn function( callback, isOne ) {\n\t\tthis.on.call(this, type, callback, isOne);\n\t};\n};\n\nfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\tvar type =  eventTypes[i];\n\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n}\n\nmodule.exports = ElementWatcher;\n\n\n\n// WEBPACK FOOTER //\n// ./src/watcher.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _require = __webpack_require__(1),\n\t    isInBrowser = _require.isInBrowser;\n\t\n\tvar ScrollMonitorContainer = __webpack_require__(2);\n\t\n\tvar scrollMonitor = new ScrollMonitorContainer(isInBrowser ? document.body : null);\n\tscrollMonitor.setStateFromDOM(null);\n\tscrollMonitor.listenToDOM();\n\t\n\tif (isInBrowser) {\n\t\twindow.scrollMonitor = scrollMonitor;\n\t}\n\t\n\tmodule.exports = scrollMonitor;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\texports.VISIBILITYCHANGE = 'visibilityChange';\n\texports.ENTERVIEWPORT = 'enterViewport';\n\texports.FULLYENTERVIEWPORT = 'fullyEnterViewport';\n\texports.EXITVIEWPORT = 'exitViewport';\n\texports.PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\n\texports.LOCATIONCHANGE = 'locationChange';\n\texports.STATECHANGE = 'stateChange';\n\t\n\texports.eventTypes = [exports.VISIBILITYCHANGE, exports.ENTERVIEWPORT, exports.FULLYENTERVIEWPORT, exports.EXITVIEWPORT, exports.PARTIALLYEXITVIEWPORT, exports.LOCATIONCHANGE, exports.STATECHANGE];\n\t\n\texports.isOnServer = typeof window === 'undefined';\n\texports.isInBrowser = !exports.isOnServer;\n\t\n\texports.defaultOffsets = { top: 0, bottom: 0 };\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _require = __webpack_require__(1),\n\t    isOnServer = _require.isOnServer,\n\t    isInBrowser = _require.isInBrowser,\n\t    eventTypes = _require.eventTypes;\n\t\n\tvar Watcher = __webpack_require__(3);\n\t\n\tfunction getViewportHeight(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t\t} else {\n\t\t\treturn element.clientHeight;\n\t\t}\n\t}\n\t\n\tfunction getContentHeight(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\n\t\tif (element === document.body) {\n\t\t\t// jQuery approach\n\t\t\t// whichever is greatest\n\t\t\treturn Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight);\n\t\t} else {\n\t\t\treturn element.scrollHeight;\n\t\t}\n\t}\n\t\n\tfunction scrollTop(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.pageYOffset || document.documentElement && document.documentElement.scrollTop || document.body.scrollTop;\n\t\t} else {\n\t\t\treturn element.scrollTop;\n\t\t}\n\t}\n\t\n\tvar browserSupportsPassive = false;\n\tif (isInBrowser) {\n\t\ttry {\n\t\t\tvar opts = Object.defineProperty({}, 'passive', {\n\t\t\t\tget: function get() {\n\t\t\t\t\tbrowserSupportsPassive = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\twindow.addEventListener('test', null, opts);\n\t\t} catch (e) {}\n\t}\n\tvar useCapture = browserSupportsPassive ? { capture: false, passive: true } : false;\n\t\n\tvar ScrollMonitorContainer = function () {\n\t\tfunction ScrollMonitorContainer(item, parentWatcher) {\n\t\t\t_classCallCheck(this, ScrollMonitorContainer);\n\t\n\t\t\tvar self = this;\n\t\n\t\t\tthis.item = item;\n\t\t\tthis.watchers = [];\n\t\t\tthis.viewportTop = null;\n\t\t\tthis.viewportBottom = null;\n\t\t\tthis.documentHeight = getContentHeight(item);\n\t\t\tthis.viewportHeight = getViewportHeight(item);\n\t\t\tthis.DOMListener = function () {\n\t\t\t\tScrollMonitorContainer.prototype.DOMListener.apply(self, arguments);\n\t\t\t};\n\t\t\tthis.eventTypes = eventTypes;\n\t\n\t\t\tif (parentWatcher) {\n\t\t\t\tthis.containerWatcher = parentWatcher.create(item);\n\t\t\t}\n\t\n\t\t\tvar previousDocumentHeight;\n\t\n\t\t\tvar calculateViewportI;\n\t\t\tfunction calculateViewport() {\n\t\t\t\tself.viewportTop = scrollTop(item);\n\t\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\t\twhile (calculateViewportI--) {\n\t\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t\t}\n\t\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar updateAndTriggerWatchersI;\n\t\t\tfunction updateAndTriggerWatchers() {\n\t\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t\t}\n\t\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.update = function () {\n\t\t\t\tcalculateViewport();\n\t\t\t\tupdateAndTriggerWatchers();\n\t\t\t};\n\t\t\tthis.recalculateLocations = function () {\n\t\t\t\tthis.documentHeight = 0;\n\t\t\t\tthis.update();\n\t\t\t};\n\t\t}\n\t\n\t\tScrollMonitorContainer.prototype.listenToDOM = function listenToDOM() {\n\t\t\tif (isInBrowser) {\n\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t}\n\t\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\t// Old IE support\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t\t}\n\t\t\t\tthis.destroy = function () {\n\t\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Old IE support\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.destroy = function destroy() {\n\t\t\t// noop, override for your own purposes.\n\t\t\t// in listenToDOM, for example.\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.DOMListener = function DOMListener(event) {\n\t\t\t//alert('got scroll');\n\t\t\tthis.setStateFromDOM(event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.setStateFromDOM = function setStateFromDOM(event) {\n\t\t\tvar viewportTop = scrollTop(this.item);\n\t\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\t\tvar contentHeight = getContentHeight(this.item);\n\t\n\t\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.setState = function setState(newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\t\tvar needsRecalcuate = newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight;\n\t\n\t\t\tthis.latestEvent = event;\n\t\t\tthis.viewportTop = newViewportTop;\n\t\t\tthis.viewportHeight = newViewportHeight;\n\t\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\t\tthis.contentHeight = newContentHeight;\n\t\n\t\t\tif (needsRecalcuate) {\n\t\t\t\tvar i = this.watchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.updateAndTriggerWatchers(event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.updateAndTriggerWatchers = function updateAndTriggerWatchers(event) {\n\t\t\tvar i = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].update();\n\t\t\t}\n\t\n\t\t\ti = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t\t}\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.createCustomContainer = function createCustomContainer() {\n\t\t\treturn new ScrollMonitorContainer();\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.createContainer = function createContainer(item) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.querySelector(item);\n\t\t\t} else if (item && item.length > 0) {\n\t\t\t\titem = item[0];\n\t\t\t}\n\t\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\t\tcontainer.setStateFromDOM();\n\t\t\tcontainer.listenToDOM();\n\t\t\treturn container;\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.create = function create(item, offsets) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.querySelector(item);\n\t\t\t} else if (item && item.length > 0) {\n\t\t\t\titem = item[0];\n\t\t\t}\n\t\t\tvar watcher = new Watcher(this, item, offsets);\n\t\t\tthis.watchers.push(watcher);\n\t\t\treturn watcher;\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.beget = function beget(item, offsets) {\n\t\t\treturn this.create(item, offsets);\n\t\t};\n\t\n\t\treturn ScrollMonitorContainer;\n\t}();\n\t\n\tmodule.exports = ScrollMonitorContainer;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _require = __webpack_require__(1),\n\t    VISIBILITYCHANGE = _require.VISIBILITYCHANGE,\n\t    ENTERVIEWPORT = _require.ENTERVIEWPORT,\n\t    FULLYENTERVIEWPORT = _require.FULLYENTERVIEWPORT,\n\t    EXITVIEWPORT = _require.EXITVIEWPORT,\n\t    PARTIALLYEXITVIEWPORT = _require.PARTIALLYEXITVIEWPORT,\n\t    LOCATIONCHANGE = _require.LOCATIONCHANGE,\n\t    STATECHANGE = _require.STATECHANGE,\n\t    eventTypes = _require.eventTypes,\n\t    defaultOffsets = _require.defaultOffsets;\n\t\n\tfunction ElementWatcher(containerWatcher, watchItem, offsets) {\n\t\tvar self = this;\n\t\n\t\tthis.watchItem = watchItem;\n\t\tthis.container = containerWatcher;\n\t\n\t\tif (!offsets) {\n\t\t\tthis.offsets = defaultOffsets;\n\t\t} else if (offsets === +offsets) {\n\t\t\tthis.offsets = { top: offsets, bottom: offsets };\n\t\t} else {\n\t\t\tthis.offsets = {\n\t\t\t\ttop: offsets.top || defaultOffsets.top,\n\t\t\t\tbottom: offsets.bottom || defaultOffsets.bottom\n\t\t\t};\n\t\t}\n\t\n\t\tthis.callbacks = {}; // {callback: function, isOne: true }\n\t\n\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[eventTypes[i]] = [];\n\t\t}\n\t\n\t\tthis.locked = false;\n\t\n\t\tvar wasInViewport;\n\t\tvar wasFullyInViewport;\n\t\tvar wasAboveViewport;\n\t\tvar wasBelowViewport;\n\t\n\t\tvar listenerToTriggerListI;\n\t\tvar listener;\n\t\tfunction triggerCallbackArray(listeners, event) {\n\t\t\tif (listeners.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenerToTriggerListI = listeners.length;\n\t\t\twhile (listenerToTriggerListI--) {\n\t\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\t\tlistener.callback.call(self, event, self);\n\t\t\t\tif (listener.isOne) {\n\t\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.triggerCallbacks = function triggerCallbacks(event) {\n\t\n\t\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[ENTERVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[FULLYENTERVIEWPORT], event);\n\t\t\t}\n\t\n\t\t\tif (this.isAboveViewport !== wasAboveViewport && this.isBelowViewport !== wasBelowViewport) {\n\t\n\t\t\t\ttriggerCallbackArray(this.callbacks[VISIBILITYCHANGE], event);\n\t\n\t\t\t\t// if you skip completely past this element\n\t\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[FULLYENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[PARTIALLYEXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[ENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[EXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[PARTIALLYEXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[EXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[VISIBILITYCHANGE], event);\n\t\t\t}\n\t\t\tswitch (true) {\n\t\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[STATECHANGE], event);\n\t\t\t}\n\t\n\t\t\twasInViewport = this.isInViewport;\n\t\t\twasFullyInViewport = this.isFullyInViewport;\n\t\t\twasAboveViewport = this.isAboveViewport;\n\t\t\twasBelowViewport = this.isBelowViewport;\n\t\t};\n\t\n\t\tthis.recalculateLocation = function () {\n\t\t\tif (this.locked) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar previousTop = this.top;\n\t\t\tvar previousBottom = this.bottom;\n\t\t\tif (this.watchItem.nodeName) {\n\t\t\t\t// a dom element\n\t\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t\t}\n\t\n\t\t\t\tvar containerOffset = 0;\n\t\t\t\tvar container = this.container;\n\t\t\t\twhile (container.containerWatcher) {\n\t\t\t\t\tcontainerOffset += container.containerWatcher.top - container.containerWatcher.container.viewportTop;\n\t\t\t\t\tcontainer = container.containerWatcher.container;\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\t\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t\t}\n\t\t\t} else if (this.watchItem === +this.watchItem) {\n\t\t\t\t// number\n\t\t\t\tif (this.watchItem > 0) {\n\t\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t\t} else {\n\t\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// an object with a top and bottom property\n\t\t\t\tthis.top = this.watchItem.top;\n\t\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t\t}\n\t\n\t\t\tthis.top -= this.offsets.top;\n\t\t\tthis.bottom += this.offsets.bottom;\n\t\t\tthis.height = this.bottom - this.top;\n\t\n\t\t\tif ((previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom)) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[LOCATIONCHANGE], null);\n\t\t\t}\n\t\t};\n\t\n\t\tthis.recalculateLocation();\n\t\tthis.update();\n\t\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\t}\n\t\n\tElementWatcher.prototype = {\n\t\ton: function on(event, callback, isOne) {\n\t\n\t\t\t// trigger the event if it applies to the element right now.\n\t\t\tswitch (true) {\n\t\t\t\tcase event === VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\t\tcase event === ENTERVIEWPORT && this.isInViewport:\n\t\t\t\tcase event === FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\t\tcase event === EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\t\tcase event === PARTIALLYEXITVIEWPORT && this.isInViewport && this.isAboveViewport:\n\t\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\t\tif (isOne) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tthis.callbacks[event].push({ callback: callback, isOne: isOne || false });\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to add a scroll monitor listener of type ' + event + '. Your options are: ' + eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\toff: function off(event, callback) {\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type ' + event + '. Your options are: ' + eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\tone: function one(event, callback) {\n\t\t\tthis.on(event, callback, true);\n\t\t},\n\t\trecalculateSize: function recalculateSize() {\n\t\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\t\tthis.bottom = this.top + this.height;\n\t\t},\n\t\tupdate: function update() {\n\t\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\t\n\t\t\tthis.isInViewport = this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop;\n\t\t\tthis.isFullyInViewport = this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom || this.isAboveViewport && this.isBelowViewport;\n\t\t},\n\t\tdestroy: function destroy() {\n\t\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\t    self = this;\n\t\t\tthis.container.watchers.splice(index, 1);\n\t\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\t\tself.callbacks[eventTypes[i]].length = 0;\n\t\t\t}\n\t\t},\n\t\t// prevent recalculating the element location\n\t\tlock: function lock() {\n\t\t\tthis.locked = true;\n\t\t},\n\t\tunlock: function unlock() {\n\t\t\tthis.locked = false;\n\t\t}\n\t};\n\t\n\tvar eventHandlerFactory = function eventHandlerFactory(type) {\n\t\treturn function (callback, isOne) {\n\t\t\tthis.on.call(this, type, callback, isOne);\n\t\t};\n\t};\n\t\n\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\tvar type = eventTypes[i];\n\t\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n\t}\n\t\n\tmodule.exports = ElementWatcher;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// scrollMonitor.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b221bc136e7e9b3db562","var { isInBrowser } = require('./src/constants');\n\nvar ScrollMonitorContainer = require('./src/container');\n\nvar scrollMonitor = new ScrollMonitorContainer(isInBrowser ? document.body : null);\nscrollMonitor.setStateFromDOM(null);\nscrollMonitor.listenToDOM();\n\nif (isInBrowser) {\n\twindow.scrollMonitor = scrollMonitor;\n}\n\nmodule.exports = scrollMonitor;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","exports.VISIBILITYCHANGE = 'visibilityChange';\nexports.ENTERVIEWPORT = 'enterViewport';\nexports.FULLYENTERVIEWPORT = 'fullyEnterViewport';\nexports.EXITVIEWPORT = 'exitViewport';\nexports.PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\nexports.LOCATIONCHANGE = 'locationChange';\nexports.STATECHANGE = 'stateChange';\n\nexports.eventTypes = [\n\texports.VISIBILITYCHANGE,\n\texports.ENTERVIEWPORT,\n\texports.FULLYENTERVIEWPORT,\n\texports.EXITVIEWPORT,\n\texports.PARTIALLYEXITVIEWPORT,\n\texports.LOCATIONCHANGE,\n\texports.STATECHANGE\n];\n\nexports.isOnServer = (typeof window === 'undefined');\nexports.isInBrowser = !exports.isOnServer;\n\nexports.defaultOffsets = {top: 0, bottom: 0};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","var { isOnServer, isInBrowser, eventTypes } = require('./constants');\nvar Watcher = require('./watcher');\n\nfunction getViewportHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t} else {\n\t\treturn element.clientHeight;\n\t}\n}\n\nfunction getContentHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\n\tif (element === document.body) {\n\t\t// jQuery approach\n\t\t// whichever is greatest\n\t\treturn Math.max(\n\t\t\tdocument.body.scrollHeight, document.documentElement.scrollHeight,\n\t\t\tdocument.body.offsetHeight, document.documentElement.offsetHeight,\n\t\t\tdocument.documentElement.clientHeight\n\t\t);\n\t} else {\n\t\treturn element.scrollHeight;\n\t}\n}\n\nfunction scrollTop (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.pageYOffset ||\n\t\t\t(document.documentElement && document.documentElement.scrollTop) ||\n\t\t\tdocument.body.scrollTop;\n\t} else {\n\t\treturn element.scrollTop;\n\t}\n}\n\nvar browserSupportsPassive = false;\nif (isInBrowser) {\n\ttry {\n\t\tvar opts = Object.defineProperty({}, 'passive', {\n\t\t\tget: function() {\n\t\t\t\tbrowserSupportsPassive = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener('test', null, opts);\n\t} catch (e) {}\n}\nconst useCapture = browserSupportsPassive ? {capture: false, passive: true} : false;\n\n\nclass ScrollMonitorContainer {\n\tconstructor (item, parentWatcher) {\n\t\tvar self = this;\n\n\t\tthis.item = item;\n\t\tthis.watchers = [];\n\t\tthis.viewportTop = null;\n\t\tthis.viewportBottom = null;\n\t\tthis.documentHeight = getContentHeight(item);\n\t\tthis.viewportHeight = getViewportHeight(item);\n\t\tthis.DOMListener = function () {\n\t\t\tScrollMonitorContainer.prototype.DOMListener.apply(self, arguments);\n\t\t};\n\t\tthis.eventTypes = eventTypes;\n\n\t\tif (parentWatcher) {\n\t\t\tthis.containerWatcher = parentWatcher.create(item);\n\t\t}\n\n\t\tvar previousDocumentHeight;\n\n\t\tvar calculateViewportI;\n\t\tfunction calculateViewport() {\n\t\t\tself.viewportTop = scrollTop(item);\n\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\twhile( calculateViewportI-- ) {\n\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t}\n\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t}\n\t\t}\n\n\t\tvar updateAndTriggerWatchersI;\n\t\tfunction updateAndTriggerWatchers() {\n\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t}\n\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update = function() {\n\t\t\tcalculateViewport();\n\t\t\tupdateAndTriggerWatchers();\n\t\t};\n\t\tthis.recalculateLocations = function() {\n\t\t\tthis.documentHeight = 0;\n\t\t\tthis.update();\n\t\t};\n\n\t}\n\n\tlistenToDOM () {\n\t\tif (isInBrowser) {\n\t\t\tif (window.addEventListener) {\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t}\n\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t} else {\n\t\t\t\t// Old IE support\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t}\n\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t}\n\t\t\tthis.destroy = function () {\n\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t}\n\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\t// Old IE support\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tdestroy () {\n\t\t// noop, override for your own purposes.\n\t\t// in listenToDOM, for example.\n\t}\n\n\tDOMListener (event) {\n\t\t//alert('got scroll');\n\t\tthis.setStateFromDOM(event);\n\t}\n\n\tsetStateFromDOM (event) {\n\t\tvar viewportTop = scrollTop(this.item);\n\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\tvar contentHeight = getContentHeight(this.item);\n\n\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t}\n\n\tsetState (newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\tvar needsRecalcuate = (newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight);\n\n\t\tthis.latestEvent = event;\n\t\tthis.viewportTop = newViewportTop;\n\t\tthis.viewportHeight = newViewportHeight;\n\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\tthis.contentHeight = newContentHeight;\n\n\t\tif (needsRecalcuate) {\n\t\t\tlet i = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t}\n\t\t}\n\t\tthis.updateAndTriggerWatchers(event);\n\t}\n\n\tupdateAndTriggerWatchers (event) {\n\t\tlet i = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].update();\n\t\t}\n\n\t\ti = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t}\n\t}\n\n\tcreateCustomContainer () {\n\t\treturn new ScrollMonitorContainer();\n\t}\n\n\tcreateContainer (item) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\tcontainer.setStateFromDOM();\n\t\tcontainer.listenToDOM();\n\t\treturn container;\n\t}\n\n\tcreate (item, offsets) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar watcher = new Watcher(this, item, offsets);\n\t\tthis.watchers.push(watcher);\n\t\treturn watcher;\n\t}\n\n\tbeget (item, offsets) {\n\t\treturn this.create(item, offsets);\n\t}\n}\n\nmodule.exports = ScrollMonitorContainer;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/container.js","import scrollMonitor from 'scrollmonitor'\r\n\r\nconst headline = document.querySelector<HTMLElement>('#focus-effect h2')!\r\n\r\n\r\nconst observer = scrollMonitor.create(headline)\r\n\r\nobserver.enterViewport(() => {\r\n  headline.classList.add('visible')\r\n})\r\n\r\nobserver.exitViewport(() => {\r\n  headline.classList.remove('visible')\r\n})\r\n"]}